# 🖥️ Operating System Experiments and Concepts

This repository contains a collection of experiments, process scheduling algorithms, and important operating system concepts, including threads, race conditions, semaphores, and more. Each folder or file represents a different experiment or a solution to a specific operating system problem.

## 📋 Table of Contents
- [Introduction](#introduction)
- [Experiments](#experiments)
  - [Process Scheduling Algorithms](#process-scheduling-algorithms)
  - [Threading and Synchronization](#threading-and-synchronization)
- [Key Concepts](#key-concepts)
  - [Race Condition](#race-condition)
  - [Semaphore](#semaphore)
  - [Deadlock](#deadlock)
- [Installation & Usage](#installation--usage)
- [Contributing](#contributing)

## 🚀 Introduction

This repository is focused on providing solutions, implementations, and explanations for various operating system topics. It includes experiments related to process scheduling, thread management, synchronization issues, and other OS-related problems. Whether you're learning OS concepts or implementing solutions, this repository is designed to be a useful resource for understanding core operating system principles.

## 🧪 Experiments

### Process Scheduling Algorithms

In this section, you will find implementations and explanations of various process scheduling algorithms that the operating system uses to manage processes.

1. **First-Come-First-Serve (FCFS)** ⏱️: A simple algorithm where the first process that arrives is executed first.
2. **Shortest Job First (SJF)** 📉: The process with the shortest burst time is selected next.
3. **Round Robin (RR)** 🔄: Processes are given equal time slices and are scheduled in a circular order.
4. **Priority Scheduling** ⭐: Processes are scheduled based on their priority.
5. **Shortest Remaining Time First (SRTF)** ⌛: Preemptive version of SJF, where the process with the shortest remaining time is given the CPU.

Each algorithm is implemented and demonstrated with example use cases.

### Threading and Synchronization

This section covers threads and synchronization mechanisms in operating systems, including the challenges and solutions related to thread management.

- **Multithreading** 🧵: How to create and manage threads in an operating system.
- **Mutexes and Semaphores** 🔒: Tools used for synchronization to avoid race conditions.
- **Producer-Consumer Problem** 🏭: A classical synchronization problem demonstrating thread coordination.
  
## 🔑 Key Concepts

### Race Condition

🏁 A race condition occurs when two or more threads attempt to modify shared data simultaneously. This can lead to unpredictable behavior and bugs. This repository demonstrates how race conditions can occur and how to prevent them using synchronization mechanisms like mutexes and semaphores.

### Semaphore

🚦 A semaphore is a synchronization primitive that controls access to shared resources. It can be used to solve various problems, such as the producer-consumer problem or controlling the number of resources that a process can access.

- **Binary Semaphore**: Often used as a lock for mutual exclusion.
- **Counting Semaphore**: Used to manage a set of resources.

### Deadlock

🔄 Deadlock is a situation where two or more processes are unable to proceed because each is waiting for the other to release resources. This section contains code to demonstrate deadlock and the methods to detect and resolve it.

## 💻 Installation & Usage

```bash
# Clone the repository
git clone https://github.com/Faisal786111/os-experiments.git

# Navigate to the repository
cd os-experiments

# Explore different experiments
cd Experiments
```

## 🤝 Contributing

Contributions are welcome! If you have any improvements or new experiments to add:

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-experiment`)
3. Commit your changes (`git commit -m 'Add some amazing experiment'`)
4. Push to the branch (`git push origin feature/amazing-experiment`)
5. Open a Pull Request
